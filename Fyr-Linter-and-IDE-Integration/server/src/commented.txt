/* var args: Array<object | string> = Array.prototype.slice.call(arguments, 0);
	if (args.length <= 1) {
		console.log(("Missing package or file information").red);
		return;
	}
	args = args.splice(args.length - 2, 1);

	let fyrPaths = Package.getFyrPaths();
	if (!fyrPaths) {
		return;
	};

	let pkg: Package;
	// Compile a package?
	if (args.length == 1) {
		let p = path.resolve(args[0] as string);
		if (p[p.length - 1] != path.sep) {
			p += path.sep;
		}
		let isdir: boolean;
		try {
			isdir = fs.lstatSync(p).isDirectory();
		} catch (e) {
			isdir = false;
		}
		if (isdir) {
			// Is this package located in one of the known pathes. If yes -> put the output in the right location
			for (let fyrPath of fyrPaths) {
				let test = path.join(path.normalize(fyrPath), "src");
				if (test[test.length - 1] != path.sep) {
					test += path.sep;
				}
				if (p.length > test.length && p.substr(0, test.length) == test) {
					let pkgPath = p.substring(test.length, p.length - 1);
					let packagePaths: Array<string> = pkgPath.split(path.sep);
					packagePaths.splice(packagePaths.length - 1, 1);
					pkg = new Package(true);
					pkg.findSources(fyrPath, pkgPath);
					break;
				}
			}
			// Not a package in one of the Fyr paths?
			if (!pkg) {
				// Determine all filenames
				let files: Array<string> = [];
				let allFiles = fs.readdirSync(p);
				for (let f of allFiles) {
					if (f.length > 4 && f.substr(f.length - 4, 4) == ".fyr") {
						files.push(path.join(p, f));
					}
				}
				pkg = new Package(true);
				pkg.setSources(files);
			}
		}
	} 

	// Compile a list of files? USE THIS
	if (!pkg) {
		let files: Array<string> = [];
		// Determine all source files to compile
		for (let i = 0; i < args.length; i++) {
			let file = args[i];
			files.push(file as string);
		}
		pkg = new Package(true);
		pkg.setSources(files);
	}

	//    if (!program.disableRuntime) {
	//        files.push(path.join(fyrBase, "runtime/mem.fyr"));
	//        files.push(path.join(fyrBase, "runtime/map.fyr"));
	//    }

	// Load all sources
	try {
		pkg.loadSources();
	} catch (ex) {
		if (ex instanceof typecheck.TypeError) {
			console.log((ex.location.file + " (" + ex.location.start.line + "," + ex.location.start.column + "): ").yellow + ex.message.red);
			return;
		} else if (ex instanceof parser.SyntaxError) {
			console.log((ast.currentFile() + " (" + ex.location.start.line + "," + ex.location.start.column + "): ").yellow + ex.message.red);
			return;
		} else if (ex instanceof ImportError) {
			if (ex.location) {
				console.log((ex.location.file + " (" + ex.location.start.line + "," + ex.location.start.column + "): ").yellow + ex.message.red);
			} else {
				console.log((ex.path + ": ".yellow) + ex.message.red);
			}
			return
		} else {
			console.log(ex);
			throw ex;
		}
	}

	// TypeCheck the sources
	try {
		Package.checkTypesForPackages();
	} catch (ex) {
		if (ex instanceof typecheck.TypeError) {
			console.log((ex.location.file + " (" + ex.location.start.line + "," + ex.location.start.column + "): ").yellow + ex.message.red);
			return;
		} else {
			console.log(ex);
			throw ex;
		}
	} */